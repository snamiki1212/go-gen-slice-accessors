package internal

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"
)

// Generator: code generation struct
type Generator struct {
	fields      fields
	pkgName     string
	sliceName   string
	importPaths IImportPaths
}

type IImportPaths interface {
	Display() string
}

const templateBody = `
// {{ .Method }}
func (xs {{ .Slice }}) {{ .Method }}() []{{ .Type }} {
	sli := make([]{{ .Type }}, 0, len(xs))
	for i := range xs {
		sli = append(sli, xs[i].{{ .Field }})
	}
	return sli
}
`

// Replace variable from key to value in template.
type templateMapper struct {
	Slice  string // Slice name for target struct (ex. Users).
	Method string // Method name of accessor (ex. UserIDs).
	Type   string // Type name of field (ex. string).
	Field  string // Field name of struct (ex. UserID).
}

func NewTemplateMappers(slice string, fields fields) []*templateMapper {
	var mappers []*templateMapper
	for _, field := range fields {
		mappers = append(mappers, NewTemplateMapper(slice, field.Accessor, field.Type, field.Name))
	}
	return mappers
}

func NewTemplateMapper(slice, method, typ, field string) *templateMapper {
	return &templateMapper{
		Slice:  slice,
		Method: method,
		Type:   typ,
		Field:  field,
	}
}

// Generate code
func (g Generator) Generate() (string, error) {
	if len(g.fields) == 0 {
		return "", nil
	}

	var txt string

	// Append header
	txt += "// Code generated by \"go-gen-slice-accessors\"; DO NOT EDIT.\n"
	txt += "// Based on information from https://github.com/snamiki1212/go-gen-slice-accessors\n"
	txt += "\n"
	txt += fmt.Sprintf("package %s\n", g.pkgName)
	txt += g.importPaths.Display()

	// Append template
	templateStr, err := g.generateTemplate()
	if err != nil {
		return "", fmt.Errorf("generate template error: %w", err)
	}
	txt += templateStr

	// format (go fmt)
	btxt, err := format.Source([]byte(txt))
	if err != nil {
		return "", fmt.Errorf("format error: %w", err)
	}

	txt = string(btxt)

	return txt, nil
}

// Generate template
func (g Generator) generateTemplate() (string, error) {
	// New template
	tp, err := template.New("").Parse(templateBody)
	if err != nil {
		return "", fmt.Errorf("template parse error: %w", err)
	}

	// Create template mappers
	mappers := NewTemplateMappers(g.sliceName, g.fields)

	// Build template
	var doc bytes.Buffer
	for _, info := range mappers {
		err = tp.Execute(&doc, info)
		if err != nil {
			return "", fmt.Errorf("template execute error: %w", err)
		}
	}

	return doc.String(), nil
}
